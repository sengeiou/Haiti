package com.aimir.fep.protocol.fmp.frame.service.entry;

import javax.xml.bind.annotation.XmlTransient;

import com.aimir.fep.protocol.fmp.datatype.*;
import com.aimir.fep.protocol.fmp.frame.service.Entry;

/**
 * sinkEntry
 * generated by MIB Tool, Do not modify
 *
 * @author Y.S Kim (sorimo@nuritelecom.com)
 * @version $Rev: 1 $, $Date: 2005-11-21 15:59:15 +0900 $,
 */
public class sinkEntry extends Entry {

	public BYTE sinkMask = 
			new BYTE();

	public BYTE sinkIndex = 
			new BYTE();

	public HEX sinkID = 
			new HEX(8);

	public OCTET sinkDevice = 
			new OCTET(16);

	public BYTE sinkType = 
			new BYTE();

	public BYTE sinkMaxBind = 
			new BYTE();

	public BYTE sinkChannel = 
			new BYTE();

	public WORD sinkPanID = 
			new WORD();

	public BYTE sinkNeighborNode = 
			new BYTE();

	public BYTE sinkAES = 
			new BYTE();

	public UINT sinkBaudrate = 
			new UINT();

	public BYTE sinkState = 
			new BYTE();

	public BYTE sinkMaxActiveCount = 
			new BYTE();

	public BYTE sinkResetKind = 
			new BYTE();

	public WORD sinkPC = 
			new WORD();

	public TIMESTAMP sinkLastConnect = 
			new TIMESTAMP(7);

	public TIMESTAMP sinkLastDisconnect = 
			new TIMESTAMP(7);

	public TIMESTAMP sinkLastReset = 
			new TIMESTAMP(7);

	@XmlTransient
	public BYTE getSinkMask()
	{
		 return this.sinkMask;
	}

	public void setSinkMask(BYTE sinkMask)
	{
		 this.sinkMask=sinkMask;
	}

	@XmlTransient
	public BYTE getSinkIndex()
	{
		 return this.sinkIndex;
	}

	public void setSinkIndex(BYTE sinkIndex)
	{
		 this.sinkIndex=sinkIndex;
	}

	@XmlTransient
	public HEX getSinkID()
	{
		 return this.sinkID;
	}

	public void setSinkID(HEX sinkID)
	{
		 this.sinkID=sinkID;
	}

	@XmlTransient
	public OCTET getSinkDevice()
	{
		 return this.sinkDevice;
	}

	public void setSinkDevice(OCTET sinkDevice)
	{
		 this.sinkDevice=sinkDevice;
	}

	@XmlTransient
	public BYTE getSinkType()
	{
		 return this.sinkType;
	}

	public void setSinkType(BYTE sinkType)
	{
		 this.sinkType=sinkType;
	}

	@XmlTransient
	public BYTE getSinkMaxBind()
	{
		 return this.sinkMaxBind;
	}

	public void setSinkMaxBind(BYTE sinkMaxBind)
	{
		 this.sinkMaxBind=sinkMaxBind;
	}

	@XmlTransient
	public BYTE getSinkChannel()
	{
		 return this.sinkChannel;
	}

	public void setSinkChannel(BYTE sinkChannel)
	{
		 this.sinkChannel=sinkChannel;
	}

	@XmlTransient
	public WORD getSinkPanID()
	{
		 return this.sinkPanID;
	}

	public void setSinkPanID(WORD sinkPanID)
	{
		 this.sinkPanID=sinkPanID;
	}

	@XmlTransient
	public BYTE getSinkNeighborNode()
	{
		 return this.sinkNeighborNode;
	}

	public void setSinkNeighborNode(BYTE sinkNeighborNode)
	{
		 this.sinkNeighborNode=sinkNeighborNode;
	}

	@XmlTransient
	public BYTE getSinkAES()
	{
		 return this.sinkAES;
	}

	public void setSinkAES(BYTE sinkAES)
	{
		 this.sinkAES=sinkAES;
	}

	@XmlTransient
	public UINT getSinkBaudrate()
	{
		 return this.sinkBaudrate;
	}

	public void setSinkBaudrate(UINT sinkBaudrate)
	{
		 this.sinkBaudrate=sinkBaudrate;
	}

	@XmlTransient
	public BYTE getSinkState()
	{
		 return this.sinkState;
	}

	public void setSinkState(BYTE sinkState)
	{
		 this.sinkState=sinkState;
	}

	@XmlTransient
	public BYTE getSinkMaxActiveCount()
	{
		 return this.sinkMaxActiveCount;
	}

	public void setSinkMaxActiveCount(BYTE sinkMaxActiveCount)
	{
		 this.sinkMaxActiveCount=sinkMaxActiveCount;
	}

	@XmlTransient
	public BYTE getSinkResetKind()
	{
		 return this.sinkResetKind;
	}

	public void setSinkResetKind(BYTE sinkResetKind)
	{
		 this.sinkResetKind=sinkResetKind;
	}

	@XmlTransient
	public WORD getSinkPC()
	{
		 return this.sinkPC;
	}

	public void setSinkPC(WORD sinkPC)
	{
		 this.sinkPC=sinkPC;
	}

	@XmlTransient
	public TIMESTAMP getSinkLastConnect()
	{
		 return this.sinkLastConnect;
	}

	public void setSinkLastConnect(TIMESTAMP sinkLastConnect)
	{
		 this.sinkLastConnect=sinkLastConnect;
	}

	@XmlTransient
	public TIMESTAMP getSinkLastDisconnect()
	{
		 return this.sinkLastDisconnect;
	}

	public void setSinkLastDisconnect(TIMESTAMP sinkLastDisconnect)
	{
		 this.sinkLastDisconnect=sinkLastDisconnect;
	}

	@XmlTransient
	public TIMESTAMP getSinkLastReset()
	{
		 return this.sinkLastReset;
	}

	public void setSinkLastReset(TIMESTAMP sinkLastReset)
	{
		 this.sinkLastReset=sinkLastReset;
	}


    public String toString()
    {
        StringBuffer sb = new StringBuffer();

		sb.append("CLASS["+this.getClass().getName()+"]\n");
		sb.append("sinkMask: " + sinkMask + "\n");
		sb.append("sinkIndex: " + sinkIndex + "\n");
		sb.append("sinkID: " + sinkID + "\n");
		sb.append("sinkDevice: " + sinkDevice + "\n");
		sb.append("sinkType: " + sinkType + "\n");
		sb.append("sinkMaxBind: " + sinkMaxBind + "\n");
		sb.append("sinkChannel: " + sinkChannel + "\n");
		sb.append("sinkPanID: " + sinkPanID + "\n");
		sb.append("sinkNeighborNode: " + sinkNeighborNode + "\n");
		sb.append("sinkAES: " + sinkAES + "\n");
		sb.append("sinkBaudrate: " + sinkBaudrate + "\n");
		sb.append("sinkState: " + sinkState + "\n");
		sb.append("sinkMaxActiveCount: " + sinkMaxActiveCount + "\n");
		sb.append("sinkResetKind: " + sinkResetKind + "\n");
		sb.append("sinkPC: " + sinkPC + "\n");
		sb.append("sinkLastConnect: " + sinkLastConnect + "\n");
		sb.append("sinkLastDisconnect: " + sinkLastDisconnect + "\n");
		sb.append("sinkLastReset: " + sinkLastReset + "\n");


        return sb.toString();
    }
}
